{"ast":null,"code":"import { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nimport { integer } from './integer.js';\nimport { nat } from './nat.js';\nimport { set } from './set.js';\nimport { tuple } from './tuple.js';\nimport { maxLengthFromMinLength } from './_internals/helpers/MaxLengthFromMinLength.js';\n\nfunction extractMaxIndex(indexesAndValues) {\n  let maxIndex = -1;\n\n  for (let index = 0; index !== indexesAndValues.length; ++index) {\n    maxIndex = Math.max(maxIndex, indexesAndValues[index][0]);\n  }\n\n  return maxIndex;\n}\n\nfunction arrayFromItems(length, indexesAndValues) {\n  const array = Array(length);\n\n  for (let index = 0; index !== indexesAndValues.length; ++index) {\n    const it = indexesAndValues[index];\n    if (it[0] < length) array[it[0]] = it[1];\n  }\n\n  return array;\n}\n\nexport function sparseArray(arb, constraints = {}) {\n  const {\n    minNumElements = 0,\n    maxNumElements = maxLengthFromMinLength(minNumElements),\n    maxLength = Math.min(maxLengthFromMinLength(maxNumElements), 4294967295),\n    noTrailingHole\n  } = constraints;\n\n  if (minNumElements > maxLength) {\n    throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal length of the array`);\n  }\n\n  if (minNumElements > maxNumElements) {\n    throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal number of non-holes`);\n  }\n\n  const resultedMaxNumElements = Math.min(maxNumElements, maxLength);\n  const maxIndexAuthorized = Math.max(maxLength - 1, 0);\n  const sparseArrayNoTrailingHole = convertFromNext(convertToNext(set(tuple(nat(maxIndexAuthorized), arb), {\n    minLength: minNumElements,\n    maxLength: resultedMaxNumElements,\n    compare: (itemA, itemB) => itemA[0] === itemB[0]\n  })).map(items => {\n    const lastIndex = extractMaxIndex(items);\n    return arrayFromItems(lastIndex + 1, items);\n  }, value => {\n    if (!Array.isArray(value)) {\n      throw new Error('Not supported entry type');\n    }\n\n    return Object.entries(value).map(entry => [Number(entry[0]), entry[1]]);\n  }));\n\n  if (noTrailingHole || maxLength === minNumElements) {\n    return sparseArrayNoTrailingHole;\n  }\n\n  return convertFromNext(convertToNext(tuple(sparseArrayNoTrailingHole, integer({\n    min: minNumElements,\n    max: maxLength\n  }))).map(data => {\n    const sparse = data[0];\n    const targetLength = data[1];\n\n    if (sparse.length >= targetLength) {\n      return sparse;\n    }\n\n    const longerSparse = sparse.slice();\n    longerSparse.length = targetLength;\n    return longerSparse;\n  }, value => {\n    if (!Array.isArray(value)) {\n      throw new Error('Not supported entry type');\n    }\n\n    return [value, value.length];\n  }));\n}","map":{"version":3,"sources":["/Users/thienma/Documents/GitHub/keey-token/client/node_modules/fast-check/lib/esm/arbitrary/sparseArray.js"],"names":["convertFromNext","convertToNext","integer","nat","set","tuple","maxLengthFromMinLength","extractMaxIndex","indexesAndValues","maxIndex","index","length","Math","max","arrayFromItems","array","Array","it","sparseArray","arb","constraints","minNumElements","maxNumElements","maxLength","min","noTrailingHole","Error","resultedMaxNumElements","maxIndexAuthorized","sparseArrayNoTrailingHole","minLength","compare","itemA","itemB","map","items","lastIndex","value","isArray","Object","entries","entry","Number","data","sparse","targetLength","longerSparse","slice"],"mappings":"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","sourcesContent":["import { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nimport { integer } from './integer.js';\nimport { nat } from './nat.js';\nimport { set } from './set.js';\nimport { tuple } from './tuple.js';\nimport { maxLengthFromMinLength } from './_internals/helpers/MaxLengthFromMinLength.js';\nfunction extractMaxIndex(indexesAndValues) {\n    let maxIndex = -1;\n    for (let index = 0; index !== indexesAndValues.length; ++index) {\n        maxIndex = Math.max(maxIndex, indexesAndValues[index][0]);\n    }\n    return maxIndex;\n}\nfunction arrayFromItems(length, indexesAndValues) {\n    const array = Array(length);\n    for (let index = 0; index !== indexesAndValues.length; ++index) {\n        const it = indexesAndValues[index];\n        if (it[0] < length)\n            array[it[0]] = it[1];\n    }\n    return array;\n}\nexport function sparseArray(arb, constraints = {}) {\n    const { minNumElements = 0, maxNumElements = maxLengthFromMinLength(minNumElements), maxLength = Math.min(maxLengthFromMinLength(maxNumElements), 4294967295), noTrailingHole, } = constraints;\n    if (minNumElements > maxLength) {\n        throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal length of the array`);\n    }\n    if (minNumElements > maxNumElements) {\n        throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal number of non-holes`);\n    }\n    const resultedMaxNumElements = Math.min(maxNumElements, maxLength);\n    const maxIndexAuthorized = Math.max(maxLength - 1, 0);\n    const sparseArrayNoTrailingHole = convertFromNext(convertToNext(set(tuple(nat(maxIndexAuthorized), arb), {\n        minLength: minNumElements,\n        maxLength: resultedMaxNumElements,\n        compare: (itemA, itemB) => itemA[0] === itemB[0],\n    })).map((items) => {\n        const lastIndex = extractMaxIndex(items);\n        return arrayFromItems(lastIndex + 1, items);\n    }, (value) => {\n        if (!Array.isArray(value)) {\n            throw new Error('Not supported entry type');\n        }\n        return Object.entries(value).map((entry) => [Number(entry[0]), entry[1]]);\n    }));\n    if (noTrailingHole || maxLength === minNumElements) {\n        return sparseArrayNoTrailingHole;\n    }\n    return convertFromNext(convertToNext(tuple(sparseArrayNoTrailingHole, integer({ min: minNumElements, max: maxLength }))).map((data) => {\n        const sparse = data[0];\n        const targetLength = data[1];\n        if (sparse.length >= targetLength) {\n            return sparse;\n        }\n        const longerSparse = sparse.slice();\n        longerSparse.length = targetLength;\n        return longerSparse;\n    }, (value) => {\n        if (!Array.isArray(value)) {\n            throw new Error('Not supported entry type');\n        }\n        return [value, value.length];\n    }));\n}\n"]},"metadata":{},"sourceType":"module"}