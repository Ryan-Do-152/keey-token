{"ast":null,"code":"import { Stream } from '../../stream/Stream.js';\nimport { cloneIfNeeded, cloneMethod } from '../../check/symbols.js';\nimport { integer } from '../integer.js';\nimport { makeLazy } from '../../stream/LazyIterableIterator.js';\nimport { buildCompareFilter } from './helpers/BuildCompareFilter.js';\nimport { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';\nimport { convertToNext } from '../../check/arbitrary/definition/Converters.js';\nimport { NextValue } from '../../check/arbitrary/definition/NextValue.js';\nexport class ArrayArbitrary extends NextArbitrary {\n  constructor(arb, minLength, maxLength, isEqual) {\n    super();\n    this.arb = arb;\n    this.minLength = minLength;\n    this.maxLength = maxLength;\n    this.isEqual = isEqual;\n    this.lengthArb = convertToNext(integer(minLength, maxLength));\n    this.preFilter = this.isEqual !== undefined ? buildCompareFilter(this.isEqual) : tab => tab;\n  }\n\n  static makeItCloneable(vs, shrinkables) {\n    vs[cloneMethod] = () => {\n      const cloned = [];\n\n      for (let idx = 0; idx !== shrinkables.length; ++idx) {\n        cloned.push(shrinkables[idx].value);\n      }\n\n      this.makeItCloneable(cloned, shrinkables);\n      return cloned;\n    };\n\n    return vs;\n  }\n\n  static canAppendItem(items, newItem, isEqual) {\n    for (let idx = 0; idx !== items.length; ++idx) {\n      if (isEqual(items[idx].value_, newItem.value_)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  generateNItemsNoDuplicates(N, mrng, biasFactorItems) {\n    let numSkippedInRow = 0;\n    const items = [];\n\n    while (items.length < N && numSkippedInRow < this.maxLength) {\n      const current = this.arb.generate(mrng, biasFactorItems);\n\n      if (this.isEqual === undefined || ArrayArbitrary.canAppendItem(items, current, this.isEqual)) {\n        numSkippedInRow = 0;\n        items.push(current);\n      } else {\n        numSkippedInRow += 1;\n      }\n    }\n\n    return items;\n  }\n\n  generateNItems(N, mrng, biasFactorItems) {\n    const items = [];\n\n    for (let index = 0; index !== N; ++index) {\n      const current = this.arb.generate(mrng, biasFactorItems);\n      items.push(current);\n    }\n\n    return items;\n  }\n\n  wrapper(itemsRaw, shrunkOnce, itemsRawLengthContext, startIndex) {\n    const items = shrunkOnce ? this.preFilter(itemsRaw) : itemsRaw;\n    let cloneable = false;\n    const vs = [];\n    const itemsContexts = [];\n\n    for (let idx = 0; idx !== items.length; ++idx) {\n      const s = items[idx];\n      cloneable = cloneable || s.hasToBeCloned;\n      vs.push(s.value);\n      itemsContexts.push(s.context);\n    }\n\n    if (cloneable) {\n      ArrayArbitrary.makeItCloneable(vs, items);\n    }\n\n    const context = {\n      shrunkOnce,\n      lengthContext: itemsRaw.length === items.length && itemsRawLengthContext !== undefined ? itemsRawLengthContext : undefined,\n      itemsContexts,\n      startIndex\n    };\n    return new NextValue(vs, context);\n  }\n\n  generate(mrng, biasFactor) {\n    const biasMeta = this.applyBias(mrng, biasFactor);\n    const targetSize = biasMeta.size;\n    const items = this.isEqual !== undefined ? this.generateNItemsNoDuplicates(targetSize, mrng, biasMeta.biasFactorItems) : this.generateNItems(targetSize, mrng, biasMeta.biasFactorItems);\n    return this.wrapper(items, false, undefined, 0);\n  }\n\n  applyBias(mrng, biasFactor) {\n    if (biasFactor === undefined) {\n      return {\n        size: this.lengthArb.generate(mrng, undefined).value\n      };\n    }\n\n    if (this.minLength === this.maxLength) {\n      return {\n        size: this.lengthArb.generate(mrng, undefined).value,\n        biasFactorItems: biasFactor\n      };\n    }\n\n    if (mrng.nextInt(1, biasFactor) !== 1) {\n      return {\n        size: this.lengthArb.generate(mrng, undefined).value\n      };\n    }\n\n    if (mrng.nextInt(1, biasFactor) !== 1 || this.minLength === this.maxLength) {\n      return {\n        size: this.lengthArb.generate(mrng, undefined).value,\n        biasFactorItems: biasFactor\n      };\n    }\n\n    const maxBiasedLength = this.minLength + Math.floor(Math.log(this.maxLength - this.minLength) / Math.log(2));\n    const targetSizeValue = convertToNext(integer(this.minLength, maxBiasedLength)).generate(mrng, undefined);\n    return {\n      size: targetSizeValue.value,\n      biasFactorItems: biasFactor\n    };\n  }\n\n  canShrinkWithoutContext(value) {\n    if (!Array.isArray(value) || this.minLength > value.length || value.length > this.maxLength) {\n      return false;\n    }\n\n    for (let index = 0; index !== value.length; ++index) {\n      if (!(index in value)) {\n        return false;\n      }\n\n      if (!this.arb.canShrinkWithoutContext(value[index])) {\n        return false;\n      }\n    }\n\n    const filtered = this.preFilter(value.map(item => new NextValue(item, undefined)));\n    return filtered.length === value.length;\n  }\n\n  shrinkItemByItem(value, safeContext, endIndex) {\n    let shrinks = Stream.nil();\n\n    for (let index = safeContext.startIndex; index < endIndex; ++index) {\n      shrinks = shrinks.join(makeLazy(() => this.arb.shrink(value[index], safeContext.itemsContexts[index]).map(v => {\n        const beforeCurrent = value.slice(0, index).map((v, i) => new NextValue(cloneIfNeeded(v), safeContext.itemsContexts[i]));\n        const afterCurrent = value.slice(index + 1).map((v, i) => new NextValue(cloneIfNeeded(v), safeContext.itemsContexts[i + index + 1]));\n        return [beforeCurrent.concat(v).concat(afterCurrent), undefined, index];\n      })));\n    }\n\n    return shrinks;\n  }\n\n  shrinkImpl(value, context) {\n    if (value.length === 0) {\n      return Stream.nil();\n    }\n\n    const safeContext = context !== undefined ? context : {\n      shrunkOnce: false,\n      lengthContext: undefined,\n      itemsContexts: [],\n      startIndex: 0\n    };\n    return this.lengthArb.shrink(value.length, safeContext.lengthContext).drop(safeContext.shrunkOnce && safeContext.lengthContext === undefined && value.length > this.minLength + 1 ? 1 : 0).map(lengthValue => {\n      const sliceStart = value.length - lengthValue.value;\n      return [value.slice(sliceStart).map((v, index) => new NextValue(cloneIfNeeded(v), safeContext.itemsContexts[index + sliceStart])), lengthValue.context, 0];\n    }).join(makeLazy(() => value.length > this.minLength ? this.shrinkItemByItem(value, safeContext, 1) : this.shrinkItemByItem(value, safeContext, value.length))).join(value.length > this.minLength ? makeLazy(() => {\n      const subContext = {\n        shrunkOnce: false,\n        lengthContext: undefined,\n        itemsContexts: safeContext.itemsContexts.slice(1),\n        startIndex: 0\n      };\n      return this.shrinkImpl(value.slice(1), subContext).filter(v => this.minLength <= v[0].length + 1).map(v => {\n        return [[new NextValue(cloneIfNeeded(value[0]), safeContext.itemsContexts[0])].concat(v[0]), undefined, 0];\n      });\n    }) : Stream.nil());\n  }\n\n  shrink(value, context) {\n    return this.shrinkImpl(value, context).map(contextualValue => this.wrapper(contextualValue[0], true, contextualValue[1], contextualValue[2]));\n  }\n\n}","map":{"version":3,"sources":["/Users/thienma/Documents/GitHub/keey-token/client/node_modules/fast-check/lib/esm/arbitrary/_internals/ArrayArbitrary.js"],"names":["Stream","cloneIfNeeded","cloneMethod","integer","makeLazy","buildCompareFilter","NextArbitrary","convertToNext","NextValue","ArrayArbitrary","constructor","arb","minLength","maxLength","isEqual","lengthArb","preFilter","undefined","tab","makeItCloneable","vs","shrinkables","cloned","idx","length","push","value","canAppendItem","items","newItem","value_","generateNItemsNoDuplicates","N","mrng","biasFactorItems","numSkippedInRow","current","generate","generateNItems","index","wrapper","itemsRaw","shrunkOnce","itemsRawLengthContext","startIndex","cloneable","itemsContexts","s","hasToBeCloned","context","lengthContext","biasFactor","biasMeta","applyBias","targetSize","size","nextInt","maxBiasedLength","Math","floor","log","targetSizeValue","canShrinkWithoutContext","Array","isArray","filtered","map","item","shrinkItemByItem","safeContext","endIndex","shrinks","nil","join","shrink","v","beforeCurrent","slice","i","afterCurrent","concat","shrinkImpl","drop","lengthValue","sliceStart","subContext","filter","contextualValue"],"mappings":"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","sourcesContent":["import { Stream } from '../../stream/Stream.js';\nimport { cloneIfNeeded, cloneMethod } from '../../check/symbols.js';\nimport { integer } from '../integer.js';\nimport { makeLazy } from '../../stream/LazyIterableIterator.js';\nimport { buildCompareFilter } from './helpers/BuildCompareFilter.js';\nimport { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';\nimport { convertToNext } from '../../check/arbitrary/definition/Converters.js';\nimport { NextValue } from '../../check/arbitrary/definition/NextValue.js';\nexport class ArrayArbitrary extends NextArbitrary {\n    constructor(arb, minLength, maxLength, isEqual) {\n        super();\n        this.arb = arb;\n        this.minLength = minLength;\n        this.maxLength = maxLength;\n        this.isEqual = isEqual;\n        this.lengthArb = convertToNext(integer(minLength, maxLength));\n        this.preFilter = this.isEqual !== undefined ? buildCompareFilter(this.isEqual) : (tab) => tab;\n    }\n    static makeItCloneable(vs, shrinkables) {\n        vs[cloneMethod] = () => {\n            const cloned = [];\n            for (let idx = 0; idx !== shrinkables.length; ++idx) {\n                cloned.push(shrinkables[idx].value);\n            }\n            this.makeItCloneable(cloned, shrinkables);\n            return cloned;\n        };\n        return vs;\n    }\n    static canAppendItem(items, newItem, isEqual) {\n        for (let idx = 0; idx !== items.length; ++idx) {\n            if (isEqual(items[idx].value_, newItem.value_)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    generateNItemsNoDuplicates(N, mrng, biasFactorItems) {\n        let numSkippedInRow = 0;\n        const items = [];\n        while (items.length < N && numSkippedInRow < this.maxLength) {\n            const current = this.arb.generate(mrng, biasFactorItems);\n            if (this.isEqual === undefined || ArrayArbitrary.canAppendItem(items, current, this.isEqual)) {\n                numSkippedInRow = 0;\n                items.push(current);\n            }\n            else {\n                numSkippedInRow += 1;\n            }\n        }\n        return items;\n    }\n    generateNItems(N, mrng, biasFactorItems) {\n        const items = [];\n        for (let index = 0; index !== N; ++index) {\n            const current = this.arb.generate(mrng, biasFactorItems);\n            items.push(current);\n        }\n        return items;\n    }\n    wrapper(itemsRaw, shrunkOnce, itemsRawLengthContext, startIndex) {\n        const items = shrunkOnce ? this.preFilter(itemsRaw) : itemsRaw;\n        let cloneable = false;\n        const vs = [];\n        const itemsContexts = [];\n        for (let idx = 0; idx !== items.length; ++idx) {\n            const s = items[idx];\n            cloneable = cloneable || s.hasToBeCloned;\n            vs.push(s.value);\n            itemsContexts.push(s.context);\n        }\n        if (cloneable) {\n            ArrayArbitrary.makeItCloneable(vs, items);\n        }\n        const context = {\n            shrunkOnce,\n            lengthContext: itemsRaw.length === items.length && itemsRawLengthContext !== undefined\n                ? itemsRawLengthContext\n                : undefined,\n            itemsContexts,\n            startIndex,\n        };\n        return new NextValue(vs, context);\n    }\n    generate(mrng, biasFactor) {\n        const biasMeta = this.applyBias(mrng, biasFactor);\n        const targetSize = biasMeta.size;\n        const items = this.isEqual !== undefined\n            ? this.generateNItemsNoDuplicates(targetSize, mrng, biasMeta.biasFactorItems)\n            : this.generateNItems(targetSize, mrng, biasMeta.biasFactorItems);\n        return this.wrapper(items, false, undefined, 0);\n    }\n    applyBias(mrng, biasFactor) {\n        if (biasFactor === undefined) {\n            return { size: this.lengthArb.generate(mrng, undefined).value };\n        }\n        if (this.minLength === this.maxLength) {\n            return { size: this.lengthArb.generate(mrng, undefined).value, biasFactorItems: biasFactor };\n        }\n        if (mrng.nextInt(1, biasFactor) !== 1) {\n            return { size: this.lengthArb.generate(mrng, undefined).value };\n        }\n        if (mrng.nextInt(1, biasFactor) !== 1 || this.minLength === this.maxLength) {\n            return { size: this.lengthArb.generate(mrng, undefined).value, biasFactorItems: biasFactor };\n        }\n        const maxBiasedLength = this.minLength + Math.floor(Math.log(this.maxLength - this.minLength) / Math.log(2));\n        const targetSizeValue = convertToNext(integer(this.minLength, maxBiasedLength)).generate(mrng, undefined);\n        return { size: targetSizeValue.value, biasFactorItems: biasFactor };\n    }\n    canShrinkWithoutContext(value) {\n        if (!Array.isArray(value) || this.minLength > value.length || value.length > this.maxLength) {\n            return false;\n        }\n        for (let index = 0; index !== value.length; ++index) {\n            if (!(index in value)) {\n                return false;\n            }\n            if (!this.arb.canShrinkWithoutContext(value[index])) {\n                return false;\n            }\n        }\n        const filtered = this.preFilter(value.map((item) => new NextValue(item, undefined)));\n        return filtered.length === value.length;\n    }\n    shrinkItemByItem(value, safeContext, endIndex) {\n        let shrinks = Stream.nil();\n        for (let index = safeContext.startIndex; index < endIndex; ++index) {\n            shrinks = shrinks.join(makeLazy(() => this.arb\n                .shrink(value[index], safeContext.itemsContexts[index])\n                .map((v) => {\n                const beforeCurrent = value\n                    .slice(0, index)\n                    .map((v, i) => new NextValue(cloneIfNeeded(v), safeContext.itemsContexts[i]));\n                const afterCurrent = value\n                    .slice(index + 1)\n                    .map((v, i) => new NextValue(cloneIfNeeded(v), safeContext.itemsContexts[i + index + 1]));\n                return [\n                    beforeCurrent.concat(v).concat(afterCurrent),\n                    undefined,\n                    index,\n                ];\n            })));\n        }\n        return shrinks;\n    }\n    shrinkImpl(value, context) {\n        if (value.length === 0) {\n            return Stream.nil();\n        }\n        const safeContext = context !== undefined\n            ? context\n            : { shrunkOnce: false, lengthContext: undefined, itemsContexts: [], startIndex: 0 };\n        return (this.lengthArb\n            .shrink(value.length, safeContext.lengthContext)\n            .drop(safeContext.shrunkOnce && safeContext.lengthContext === undefined && value.length > this.minLength + 1 ? 1 : 0)\n            .map((lengthValue) => {\n            const sliceStart = value.length - lengthValue.value;\n            return [\n                value\n                    .slice(sliceStart)\n                    .map((v, index) => new NextValue(cloneIfNeeded(v), safeContext.itemsContexts[index + sliceStart])),\n                lengthValue.context,\n                0,\n            ];\n        })\n            .join(makeLazy(() => value.length > this.minLength\n            ? this.shrinkItemByItem(value, safeContext, 1)\n            : this.shrinkItemByItem(value, safeContext, value.length)))\n            .join(value.length > this.minLength\n            ? makeLazy(() => {\n                const subContext = {\n                    shrunkOnce: false,\n                    lengthContext: undefined,\n                    itemsContexts: safeContext.itemsContexts.slice(1),\n                    startIndex: 0,\n                };\n                return this.shrinkImpl(value.slice(1), subContext)\n                    .filter((v) => this.minLength <= v[0].length + 1)\n                    .map((v) => {\n                    return [\n                        [new NextValue(cloneIfNeeded(value[0]), safeContext.itemsContexts[0])].concat(v[0]),\n                        undefined,\n                        0,\n                    ];\n                });\n            })\n            : Stream.nil()));\n    }\n    shrink(value, context) {\n        return this.shrinkImpl(value, context).map((contextualValue) => this.wrapper(contextualValue[0], true, contextualValue[1], contextualValue[2]));\n    }\n}\n"]},"metadata":{},"sourceType":"module"}