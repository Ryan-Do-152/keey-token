{"ast":null,"code":"const debug = require(\"debug\")(\"contract:execute\");\n\nconst PromiEvent = require(\"./promievent\");\n\nconst EventEmitter = require(\"events\");\n\nconst utils = require(\"./utils\");\n\nconst StatusError = require(\"./statuserror\");\n\nconst Reason = require(\"./reason\");\n\nconst handlers = require(\"./handlers\");\n\nconst override = require(\"./override\");\n\nconst reformat = require(\"./reformat\");\n\nconst {\n  sendTransactionManual\n} = require(\"./manual-send\");\n\nconst execute = {\n  // -----------------------------------  Helpers --------------------------------------------------\n\n  /**\n   * Retrieves gas estimate multiplied by the set gas multiplier for a `sendTransaction` call.\n   * Lacking an estimate, sets gas to have of latest blockLimit\n   * @param  {Object} params     `sendTransaction` parameters\n   * @param  {Number} blockLimit  most recent network block.blockLimit\n   * @return {Number}             gas estimate\n   */\n  getGasEstimate: function (params, blockLimit, stacktrace = false) {\n    const constructor = this;\n    const interfaceAdapter = this.interfaceAdapter;\n    return new Promise(function (accept) {\n      // Always prefer gas specified by user (if a user sets gas to 0, that is treated\n      // as undefined here and we do proceed to do gas estimation)\n      if (params.gas) return accept(params.gas);\n      if (!constructor.autoGas) return accept();\n      interfaceAdapter.estimateGas(params, stacktrace).then(gas => {\n        // there are situations where the web3 gas estimation function in interfaceAdapter\n        // fails, specifically when a transaction will revert; we still want to continue\n        // the user flow for debugging purposes if the user has enabled stacktraces; so we provide a\n        // default gas for that situation, equal to half of the blockLimit for the latest block\n        //\n        // note: this means if a transaction will revert but the user does not have stacktracing enabled,\n        // they will get an error from the gas estimation and be unable to proceed; we may need to revisit this\n        if (gas === null) {\n          const defaultGas = utils.bigNumberify(Math.floor(blockLimit / 2));\n          accept(defaultGas.toHexString());\n        } else {\n          const limit = utils.bigNumberify(blockLimit); // if we did get a numerical gas estimate from interfaceAdapter, we\n          // multiply that estimate by the gasMultiplier to help ensure we\n          // have enough gas for the transaction\n\n          const bestEstimate = utils.multiplyBigNumberByDecimal(utils.bigNumberify(gas), constructor.gasMultiplier); // Check that we don't go over blockLimit\n\n          bestEstimate.gte(limit) ? accept(limit.sub(1).toHexString()) : accept(bestEstimate.toHexString());\n        }\n      }).catch(() => accept());\n    });\n  },\n\n  /**\n   * Prepares simple wrapped calls by checking network and organizing the method inputs into\n   * objects web3 can consume.\n   * @param  {Object} constructor   TruffleContract constructor\n   * @param  {Object} methodABI     Function ABI segment w/ inputs & outputs keys.\n   * @param  {Array}  _arguments    Arguments passed to method invocation\n   * @param  {Boolean}  skipNetworkCheck    Arguments passed to skip network call for read data (calls type) methods invocation\n   * @return {Promise}              Resolves object w/ tx params disambiguated from arguments\n   */\n  prepareCall: async function (constructor, methodABI, _arguments, skipNetworkCheck) {\n    let args = Array.prototype.slice.call(_arguments);\n    let params = utils.getTxParams.call(constructor, methodABI, args);\n    args = utils.convertToEthersBN(args);\n\n    if (constructor.ens && constructor.ens.enabled) {\n      const {\n        web3\n      } = constructor;\n      const processedValues = await utils.ens.convertENSNames({\n        networkId: constructor.network_id,\n        ensSettings: constructor.ens,\n        inputArgs: args,\n        inputParams: params,\n        methodABI,\n        web3\n      });\n      args = processedValues.args;\n      params = processedValues.params;\n    } //skipNetworkCheck flag used to skip network call for read data (calls type) methods invocation\n\n\n    if (skipNetworkCheck) {\n      return {\n        args,\n        params\n      };\n    }\n\n    const network = await constructor.detectNetwork();\n    return {\n      args,\n      params,\n      network\n    };\n  },\n\n  /**\n   * Disambiguates between transaction parameter objects and BN / BigNumber objects\n   * @param  {Any}  arg\n   * @return {Boolean}\n   */\n  hasTxParams: function (arg) {\n    return utils.is_object(arg) && !utils.is_big_number(arg);\n  },\n\n  /**\n   * Parses function arguments to discover if the terminal argument specifies the `defaultBlock`\n   * to execute a call at.\n   * @param  {Array}  args      `arguments` that were passed to method\n   * @param  {Any}    lastArg    terminal argument passed to method\n   * @param  {Array}  inputs     ABI segment defining method arguments\n   * @return {Boolean}           true if final argument is `defaultBlock`\n   */\n  hasDefaultBlock: function (args, lastArg, inputs) {\n    const hasDefaultBlock = !execute.hasTxParams(lastArg) && args.length > inputs.length;\n    const hasDefaultBlockWithParams = execute.hasTxParams(lastArg) && args.length - 1 > inputs.length;\n    return hasDefaultBlock || hasDefaultBlockWithParams;\n  },\n  // -----------------------------------  Methods --------------------------------------------------\n\n  /**\n   * Executes method as .call and processes optional `defaultBlock` argument.\n   * @param  {Function} fn         method\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @return {Promise}             Return value of the call.\n   */\n  call: function (fn, methodABI, address) {\n    const constructor = this;\n    return function () {\n      let defaultBlock = constructor.web3.eth.defaultBlock || \"latest\";\n      const args = Array.prototype.slice.call(arguments);\n      const lastArg = args[args.length - 1];\n      const promiEvent = new PromiEvent(); // Extract defaultBlock parameter\n\n      if (execute.hasDefaultBlock(args, lastArg, methodABI.inputs)) {\n        defaultBlock = args.pop();\n      } //skipNetworkCheck flag passed to skip network call for read data (calls type) methods invocation\n\n\n      const skipNetworkCheck = true;\n      execute.prepareCall(constructor, methodABI, args, skipNetworkCheck).then(async ({\n        args,\n        params\n      }) => {\n        let result;\n        params.to = address;\n        promiEvent.eventEmitter.emit(\"execute:call:method\", {\n          fn: fn,\n          args: args,\n          address: address,\n          abi: methodABI,\n          contract: constructor\n        });\n        result = await fn(...args).call(params, defaultBlock);\n        result = reformat.numbers.call(constructor, result, methodABI.outputs);\n        return promiEvent.resolve(result);\n      }).catch(promiEvent.reject);\n      return promiEvent.eventEmitter;\n    };\n  },\n\n  /**\n   * Executes method as .send\n   * @param  {Function} fn         Method to invoke\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @param  {String}   address    Deployed address of the targeted instance\n   * @return {PromiEvent}          Resolves a transaction receipt (via the receipt handler)\n   */\n  send: function (fn, methodABI, address) {\n    const constructor = this;\n    const web3 = constructor.web3;\n    return function () {\n      const promiEvent = new PromiEvent(false, constructor.debugger);\n      execute.prepareCall(constructor, methodABI, arguments).then(async ({\n        args,\n        params,\n        network\n      }) => {\n        const context = {\n          contract: constructor,\n          // Can't name this field `constructor` or `_constructor`\n          promiEvent: promiEvent,\n          params: params\n        };\n        params.to = address;\n        params.data = fn ? fn(...args).encodeABI() : params.data;\n        promiEvent.eventEmitter.emit(\"execute:send:method\", {\n          fn,\n          args,\n          address,\n          abi: methodABI,\n          contract: constructor\n        });\n        const stacktrace = promiEvent.debug ? promiEvent.debug : false;\n\n        try {\n          params.gas = await execute.getGasEstimate.call(constructor, params, network.blockLimit, stacktrace);\n        } catch (error) {\n          promiEvent.reject(error);\n          return;\n        }\n\n        execute.sendTransaction(web3, params, promiEvent, context) //the crazy things we do for stacktracing...\n        .then(receipt => {\n          if (promiEvent.debug) {\n            // in this case, we need to manually invoke the handler since it\n            // hasn't been set up (hack?)\n            handlers.receipt(context, receipt);\n          } //otherwise, just let the handlers handle things\n\n        }).catch(override.start.bind(constructor, context));\n      }).catch(promiEvent.reject);\n      return promiEvent.eventEmitter;\n    };\n  },\n\n  /**\n   * Deploys an instance\n   * @param  {Object} constructorABI  Constructor ABI segment w/ inputs & outputs keys\n   * @return {PromiEvent}             Resolves a TruffleContract instance\n   */\n  deploy: function (constructorABI) {\n    const constructor = this;\n    const web3 = constructor.web3;\n    return function () {\n      let deferred;\n      const promiEvent = new PromiEvent(false, constructor.debugger, true);\n      execute.prepareCall(constructor, constructorABI, arguments).then(async ({\n        args,\n        params,\n        network\n      }) => {\n        const {\n          blockLimit\n        } = network;\n        utils.checkLibraries.apply(constructor); // Promievent and flag that allows instance to resolve (rather than just receipt)\n\n        const context = {\n          contract: constructor,\n          promiEvent,\n          onlyEmitReceipt: true\n        };\n        const options = {\n          data: constructor.binary,\n          arguments: args\n        };\n        const contract = new web3.eth.Contract(constructor.abi);\n        params.data = contract.deploy(options).encodeABI();\n        const stacktrace = promiEvent.debug ? promiEvent.debug : false;\n        params.gas = await execute.getGasEstimate.call(constructor, params, blockLimit, stacktrace);\n        context.params = params;\n        promiEvent.eventEmitter.emit(\"execute:deploy:method\", {\n          args,\n          abi: constructorABI,\n          contract: constructor\n        });\n        deferred = execute.sendTransaction(web3, params, promiEvent, context); //the crazy things we do for stacktracing...\n\n        try {\n          const receipt = await deferred;\n\n          if (receipt.status !== undefined && !receipt.status) {\n            const reason = await Reason.get(params, web3);\n            const error = new StatusError(params, context.transactionHash, receipt, reason);\n            return context.promiEvent.reject(error);\n          }\n\n          const web3Instance = new web3.eth.Contract(constructor.abi, receipt.contractAddress);\n          web3Instance.transactionHash = context.transactionHash;\n          context.promiEvent.resolve(new constructor(web3Instance));\n        } catch (web3Error) {\n          // Manage web3's 50 blocks' timeout error.\n          // Web3's own subscriptions go dead here.\n          await override.start.call(constructor, context, web3Error);\n        }\n      }).catch(promiEvent.reject);\n      return promiEvent.eventEmitter;\n    };\n  },\n\n  /**\n   * Begins listening for an event OR manages the event callback\n   * @param  {Function} fn  Solidity event method\n   * @return {Emitter}      Event emitter\n   */\n  event: function (fn) {\n    const constructor = this;\n    const decode = utils.decodeLogs;\n    let currentLogID = null; // Someone upstream is firing duplicates :/\n\n    function dedupe(id) {\n      return id === currentLogID ? false : currentLogID = id;\n    }\n\n    return function (params, callback) {\n      if (typeof params === \"function\") {\n        callback = params;\n        params = {};\n      } // As callback\n\n\n      if (callback !== undefined) {\n        const intermediary = function (err, e) {\n          if (err) return callback(err);\n          if (!dedupe(e.id)) return;\n          callback(null, decode.call(constructor, e, true)[0]);\n        };\n\n        return constructor.detectNetwork().then(() => fn.call(constructor.events, params, intermediary));\n      } // As EventEmitter\n\n\n      const emitter = new EventEmitter();\n      constructor.detectNetwork().then(() => {\n        const event = fn(params);\n        event.on(\"data\", e => dedupe(e.id) && emitter.emit(\"data\", decode.call(constructor, e, true)[0]));\n        event.on(\"changed\", e => dedupe(e.id) && emitter.emit(\"changed\", decode.call(constructor, e, true)[0]));\n        event.on(\"error\", e => emitter.emit(\"error\", e));\n      });\n      return emitter;\n    };\n  },\n\n  /**\n   * Wraps web3 `allEvents`, with additional log decoding\n   * @return {PromiEvent}  EventEmitter\n   */\n  allEvents: function (web3Instance) {\n    const constructor = this;\n    const decode = utils.decodeLogs;\n    let currentLogID = null; // Someone upstream is firing duplicates :/\n\n    function dedupe(id) {\n      return id === currentLogID ? false : currentLogID = id;\n    }\n\n    return function (params) {\n      const emitter = new EventEmitter();\n      constructor.detectNetwork().then(() => {\n        const event = web3Instance.events.allEvents(params);\n        event.on(\"data\", e => dedupe(e.id) && emitter.emit(\"data\", decode.call(constructor, e, true)[0]));\n        event.on(\"changed\", e => dedupe(e.id) && emitter.emit(\"changed\", decode.call(constructor, e, true)[0]));\n        event.on(\"error\", e => emitter.emit(\"error\", e));\n      });\n      return emitter;\n    };\n  },\n\n  /**\n   * Wraps web3 `getPastEvents`, with additional log decoding\n   * @return {Promise}  Resolves array of event objects\n   */\n  getPastEvents: function (web3Instance) {\n    const constructor = this;\n    const decode = utils.decodeLogs;\n    return function (event, options) {\n      return web3Instance.getPastEvents(event, options).then(events => decode.call(constructor, events, false));\n    };\n  },\n\n  /**\n   * Estimates gas cost of a method invocation\n   * @param  {Function} fn  Method to target\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @return {Promise}\n   */\n  estimate: function (fn, methodABI) {\n    const constructor = this;\n    return function () {\n      return execute.prepareCall(constructor, methodABI, arguments).then(res => fn(...res.args).estimateGas(res.params));\n    };\n  },\n\n  /**\n   *\n   * @param  {Function} fn  Method to target\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @return {Promise}\n   */\n  request: function (fn, methodABI, address) {\n    const constructor = this;\n    return function () {\n      return execute.prepareCall(constructor, methodABI, arguments).then(res => {\n        //clone res.params\n        let tx = {};\n\n        for (let key in res.params) {\n          tx[key] = res.params[key];\n        } //set to\n\n\n        tx.to = address; //set data\n\n        tx.data = fn(...res.args).encodeABI();\n        return tx;\n      });\n    };\n  },\n  // This gets attached to `.new` (declared as a static_method in `contract`)\n  // during bootstrapping as `estimateGas`\n  estimateDeployment: function () {\n    const constructor = this;\n    const constructorABI = constructor.abi.filter(i => i.type === \"constructor\")[0];\n    return execute.prepareCall(constructor, constructorABI, arguments).then(res => {\n      const options = {\n        data: constructor.binary,\n        arguments: res.args\n      };\n      delete res.params[\"data\"]; // Is this necessary?\n\n      const instance = new constructor.web3.eth.Contract(constructor.abi, res.params);\n      return instance.deploy(options).estimateGas(res.params);\n    });\n  },\n  // This gets attached to `.new` (declared as a static_method in `contract`)\n  // during bootstrapping as `request`\n  requestDeployment: function () {\n    const constructor = this;\n    const constructorABI = constructor.abi.filter(i => i.type === \"constructor\")[0];\n    return execute.prepareCall(constructor, constructorABI, arguments).then(res => {\n      //clone res.params\n      let tx = {};\n\n      for (let key in res.params) {\n        tx[key] = res.params[key];\n      }\n\n      const options = {\n        data: constructor.binary,\n        arguments: res.args\n      };\n      const instance = new constructor.web3.eth.Contract(constructor.abi, res.params);\n      tx.data = instance.deploy(options).encodeABI();\n      return tx;\n    });\n  },\n  //our own custom sendTransaction function, made to mimic web3's,\n  //while also being able to do things, like, say, store the transaction\n  //hash even in case of failure.  it's not as powerful in some ways,\n  //as it just returns an ordinary Promise rather than web3's PromiEvent,\n  //but it's more suited to our purposes (we're not using that PromiEvent\n  //functionality here anyway)\n  //input works the same as input to web3.sendTransaction\n  //(well, OK, it's lacking some things there too, but again, good enough\n  //for our purposes)\n  sendTransaction: async function (web3, params, promiEvent, context) {\n    //if we don't need the debugger, let's not risk any errors on our part,\n    //and just have web3 do everything\n    if (!promiEvent || !promiEvent.debug) {\n      const deferred = web3.eth.sendTransaction(params);\n      handlers.setup(deferred, context);\n      return deferred;\n    } //otherwise, do things manually!\n    //(and skip the PromiEvent stuff :-/ )\n\n\n    return sendTransactionManual(web3, params, promiEvent);\n  }\n};\nmodule.exports = execute;","map":{"version":3,"sources":["/Users/thienma/Documents/GitHub/keey-token/client/node_modules/@truffle/contract/lib/execute.js"],"names":["debug","require","PromiEvent","EventEmitter","utils","StatusError","Reason","handlers","override","reformat","sendTransactionManual","execute","getGasEstimate","params","blockLimit","stacktrace","constructor","interfaceAdapter","Promise","accept","gas","autoGas","estimateGas","then","defaultGas","bigNumberify","Math","floor","toHexString","limit","bestEstimate","multiplyBigNumberByDecimal","gasMultiplier","gte","sub","catch","prepareCall","methodABI","_arguments","skipNetworkCheck","args","Array","prototype","slice","call","getTxParams","convertToEthersBN","ens","enabled","web3","processedValues","convertENSNames","networkId","network_id","ensSettings","inputArgs","inputParams","network","detectNetwork","hasTxParams","arg","is_object","is_big_number","hasDefaultBlock","lastArg","inputs","length","hasDefaultBlockWithParams","fn","address","defaultBlock","eth","arguments","promiEvent","pop","result","to","eventEmitter","emit","abi","contract","numbers","outputs","resolve","reject","send","debugger","context","data","encodeABI","error","sendTransaction","receipt","start","bind","deploy","constructorABI","deferred","checkLibraries","apply","onlyEmitReceipt","options","binary","Contract","status","undefined","reason","get","transactionHash","web3Instance","contractAddress","web3Error","event","decode","decodeLogs","currentLogID","dedupe","id","callback","intermediary","err","e","events","emitter","on","allEvents","getPastEvents","estimate","res","request","tx","key","estimateDeployment","filter","i","type","instance","requestDeployment","setup","module","exports"],"mappings":"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","sourcesContent":["const debug = require(\"debug\")(\"contract:execute\");\nconst PromiEvent = require(\"./promievent\");\nconst EventEmitter = require(\"events\");\nconst utils = require(\"./utils\");\nconst StatusError = require(\"./statuserror\");\nconst Reason = require(\"./reason\");\nconst handlers = require(\"./handlers\");\nconst override = require(\"./override\");\nconst reformat = require(\"./reformat\");\nconst { sendTransactionManual } = require(\"./manual-send\");\n\nconst execute = {\n  // -----------------------------------  Helpers --------------------------------------------------\n  /**\n   * Retrieves gas estimate multiplied by the set gas multiplier for a `sendTransaction` call.\n   * Lacking an estimate, sets gas to have of latest blockLimit\n   * @param  {Object} params     `sendTransaction` parameters\n   * @param  {Number} blockLimit  most recent network block.blockLimit\n   * @return {Number}             gas estimate\n   */\n  getGasEstimate: function (params, blockLimit, stacktrace = false) {\n    const constructor = this;\n    const interfaceAdapter = this.interfaceAdapter;\n\n    return new Promise(function (accept) {\n      // Always prefer gas specified by user (if a user sets gas to 0, that is treated\n      // as undefined here and we do proceed to do gas estimation)\n      if (params.gas) return accept(params.gas);\n      if (!constructor.autoGas) return accept();\n\n      interfaceAdapter\n        .estimateGas(params, stacktrace)\n        .then(gas => {\n          // there are situations where the web3 gas estimation function in interfaceAdapter\n          // fails, specifically when a transaction will revert; we still want to continue\n          // the user flow for debugging purposes if the user has enabled stacktraces; so we provide a\n          // default gas for that situation, equal to half of the blockLimit for the latest block\n          //\n          // note: this means if a transaction will revert but the user does not have stacktracing enabled,\n          // they will get an error from the gas estimation and be unable to proceed; we may need to revisit this\n          if (gas === null) {\n            const defaultGas = utils.bigNumberify(Math.floor(blockLimit / 2));\n            accept(defaultGas.toHexString());\n          } else {\n            const limit = utils.bigNumberify(blockLimit);\n            // if we did get a numerical gas estimate from interfaceAdapter, we\n            // multiply that estimate by the gasMultiplier to help ensure we\n            // have enough gas for the transaction\n            const bestEstimate = utils.multiplyBigNumberByDecimal(\n              utils.bigNumberify(gas),\n              constructor.gasMultiplier\n            );\n            // Check that we don't go over blockLimit\n            bestEstimate.gte(limit)\n              ? accept(limit.sub(1).toHexString())\n              : accept(bestEstimate.toHexString());\n          }\n        })\n        .catch(() => accept());\n    });\n  },\n\n  /**\n   * Prepares simple wrapped calls by checking network and organizing the method inputs into\n   * objects web3 can consume.\n   * @param  {Object} constructor   TruffleContract constructor\n   * @param  {Object} methodABI     Function ABI segment w/ inputs & outputs keys.\n   * @param  {Array}  _arguments    Arguments passed to method invocation\n   * @param  {Boolean}  skipNetworkCheck    Arguments passed to skip network call for read data (calls type) methods invocation\n   * @return {Promise}              Resolves object w/ tx params disambiguated from arguments\n   */\n  prepareCall: async function (\n    constructor,\n    methodABI,\n    _arguments,\n    skipNetworkCheck\n  ) {\n    let args = Array.prototype.slice.call(_arguments);\n    let params = utils.getTxParams.call(constructor, methodABI, args);\n\n    args = utils.convertToEthersBN(args);\n\n    if (constructor.ens && constructor.ens.enabled) {\n      const { web3 } = constructor;\n      const processedValues = await utils.ens.convertENSNames({\n        networkId: constructor.network_id,\n        ensSettings: constructor.ens,\n        inputArgs: args,\n        inputParams: params,\n        methodABI,\n        web3\n      });\n      args = processedValues.args;\n      params = processedValues.params;\n    }\n    //skipNetworkCheck flag used to skip network call for read data (calls type) methods invocation\n    if (skipNetworkCheck) {\n      return { args, params };\n    }\n    const network = await constructor.detectNetwork();\n    return { args, params, network };\n  },\n\n  /**\n   * Disambiguates between transaction parameter objects and BN / BigNumber objects\n   * @param  {Any}  arg\n   * @return {Boolean}\n   */\n  hasTxParams: function (arg) {\n    return utils.is_object(arg) && !utils.is_big_number(arg);\n  },\n\n  /**\n   * Parses function arguments to discover if the terminal argument specifies the `defaultBlock`\n   * to execute a call at.\n   * @param  {Array}  args      `arguments` that were passed to method\n   * @param  {Any}    lastArg    terminal argument passed to method\n   * @param  {Array}  inputs     ABI segment defining method arguments\n   * @return {Boolean}           true if final argument is `defaultBlock`\n   */\n  hasDefaultBlock: function (args, lastArg, inputs) {\n    const hasDefaultBlock =\n      !execute.hasTxParams(lastArg) && args.length > inputs.length;\n    const hasDefaultBlockWithParams =\n      execute.hasTxParams(lastArg) && args.length - 1 > inputs.length;\n    return hasDefaultBlock || hasDefaultBlockWithParams;\n  },\n\n  // -----------------------------------  Methods --------------------------------------------------\n\n  /**\n   * Executes method as .call and processes optional `defaultBlock` argument.\n   * @param  {Function} fn         method\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @return {Promise}             Return value of the call.\n   */\n  call: function (fn, methodABI, address) {\n    const constructor = this;\n\n    return function () {\n      let defaultBlock = constructor.web3.eth.defaultBlock || \"latest\";\n      const args = Array.prototype.slice.call(arguments);\n      const lastArg = args[args.length - 1];\n      const promiEvent = new PromiEvent();\n\n      // Extract defaultBlock parameter\n      if (execute.hasDefaultBlock(args, lastArg, methodABI.inputs)) {\n        defaultBlock = args.pop();\n      }\n      //skipNetworkCheck flag passed to skip network call for read data (calls type) methods invocation\n      const skipNetworkCheck = true;\n      execute\n        .prepareCall(constructor, methodABI, args, skipNetworkCheck)\n        .then(async ({ args, params }) => {\n          let result;\n\n          params.to = address;\n\n          promiEvent.eventEmitter.emit(\"execute:call:method\", {\n            fn: fn,\n            args: args,\n            address: address,\n            abi: methodABI,\n            contract: constructor\n          });\n\n          result = await fn(...args).call(params, defaultBlock);\n          result = reformat.numbers.call(\n            constructor,\n            result,\n            methodABI.outputs\n          );\n          return promiEvent.resolve(result);\n        })\n        .catch(promiEvent.reject);\n\n      return promiEvent.eventEmitter;\n    };\n  },\n\n  /**\n   * Executes method as .send\n   * @param  {Function} fn         Method to invoke\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @param  {String}   address    Deployed address of the targeted instance\n   * @return {PromiEvent}          Resolves a transaction receipt (via the receipt handler)\n   */\n  send: function (fn, methodABI, address) {\n    const constructor = this;\n    const web3 = constructor.web3;\n\n    return function () {\n      const promiEvent = new PromiEvent(false, constructor.debugger);\n\n      execute\n        .prepareCall(constructor, methodABI, arguments)\n        .then(async ({ args, params, network }) => {\n          const context = {\n            contract: constructor, // Can't name this field `constructor` or `_constructor`\n            promiEvent: promiEvent,\n            params: params\n          };\n\n          params.to = address;\n          params.data = fn ? fn(...args).encodeABI() : params.data;\n\n          promiEvent.eventEmitter.emit(\"execute:send:method\", {\n            fn,\n            args,\n            address,\n            abi: methodABI,\n            contract: constructor\n          });\n\n          const stacktrace = promiEvent.debug ? promiEvent.debug : false;\n          try {\n            params.gas = await execute.getGasEstimate.call(\n              constructor,\n              params,\n              network.blockLimit,\n              stacktrace\n            );\n          } catch (error) {\n            promiEvent.reject(error);\n            return;\n          }\n\n          execute\n            .sendTransaction(web3, params, promiEvent, context) //the crazy things we do for stacktracing...\n            .then(receipt => {\n              if (promiEvent.debug) {\n                // in this case, we need to manually invoke the handler since it\n                // hasn't been set up (hack?)\n                handlers.receipt(context, receipt);\n              }\n              //otherwise, just let the handlers handle things\n            })\n            .catch(override.start.bind(constructor, context));\n        })\n        .catch(promiEvent.reject);\n\n      return promiEvent.eventEmitter;\n    };\n  },\n\n  /**\n   * Deploys an instance\n   * @param  {Object} constructorABI  Constructor ABI segment w/ inputs & outputs keys\n   * @return {PromiEvent}             Resolves a TruffleContract instance\n   */\n  deploy: function (constructorABI) {\n    const constructor = this;\n    const web3 = constructor.web3;\n\n    return function () {\n      let deferred;\n      const promiEvent = new PromiEvent(false, constructor.debugger, true);\n\n      execute\n        .prepareCall(constructor, constructorABI, arguments)\n        .then(async ({ args, params, network }) => {\n          const { blockLimit } = network;\n\n          utils.checkLibraries.apply(constructor);\n\n          // Promievent and flag that allows instance to resolve (rather than just receipt)\n          const context = {\n            contract: constructor,\n            promiEvent,\n            onlyEmitReceipt: true\n          };\n\n          const options = {\n            data: constructor.binary,\n            arguments: args\n          };\n\n          const contract = new web3.eth.Contract(constructor.abi);\n          params.data = contract.deploy(options).encodeABI();\n          const stacktrace = promiEvent.debug ? promiEvent.debug : false;\n\n          params.gas = await execute.getGasEstimate.call(\n            constructor,\n            params,\n            blockLimit,\n            stacktrace\n          );\n\n          context.params = params;\n\n          promiEvent.eventEmitter.emit(\"execute:deploy:method\", {\n            args,\n            abi: constructorABI,\n            contract: constructor\n          });\n\n          deferred = execute.sendTransaction(web3, params, promiEvent, context); //the crazy things we do for stacktracing...\n\n          try {\n            const receipt = await deferred;\n            if (receipt.status !== undefined && !receipt.status) {\n              const reason = await Reason.get(params, web3);\n\n              const error = new StatusError(\n                params,\n                context.transactionHash,\n                receipt,\n                reason\n              );\n\n              return context.promiEvent.reject(error);\n            }\n\n            const web3Instance = new web3.eth.Contract(\n              constructor.abi,\n              receipt.contractAddress\n            );\n            web3Instance.transactionHash = context.transactionHash;\n\n            context.promiEvent.resolve(new constructor(web3Instance));\n          } catch (web3Error) {\n            // Manage web3's 50 blocks' timeout error.\n            // Web3's own subscriptions go dead here.\n            await override.start.call(constructor, context, web3Error);\n          }\n        })\n        .catch(promiEvent.reject);\n\n      return promiEvent.eventEmitter;\n    };\n  },\n\n  /**\n   * Begins listening for an event OR manages the event callback\n   * @param  {Function} fn  Solidity event method\n   * @return {Emitter}      Event emitter\n   */\n  event: function (fn) {\n    const constructor = this;\n    const decode = utils.decodeLogs;\n    let currentLogID = null;\n\n    // Someone upstream is firing duplicates :/\n    function dedupe(id) {\n      return id === currentLogID ? false : (currentLogID = id);\n    }\n\n    return function (params, callback) {\n      if (typeof params === \"function\") {\n        callback = params;\n        params = {};\n      }\n\n      // As callback\n      if (callback !== undefined) {\n        const intermediary = function (err, e) {\n          if (err) return callback(err);\n          if (!dedupe(e.id)) return;\n          callback(null, decode.call(constructor, e, true)[0]);\n        };\n\n        return constructor\n          .detectNetwork()\n          .then(() => fn.call(constructor.events, params, intermediary));\n      }\n\n      // As EventEmitter\n      const emitter = new EventEmitter();\n\n      constructor.detectNetwork().then(() => {\n        const event = fn(params);\n\n        event.on(\n          \"data\",\n          e =>\n            dedupe(e.id) &&\n            emitter.emit(\"data\", decode.call(constructor, e, true)[0])\n        );\n        event.on(\n          \"changed\",\n          e =>\n            dedupe(e.id) &&\n            emitter.emit(\"changed\", decode.call(constructor, e, true)[0])\n        );\n        event.on(\"error\", e => emitter.emit(\"error\", e));\n      });\n\n      return emitter;\n    };\n  },\n\n  /**\n   * Wraps web3 `allEvents`, with additional log decoding\n   * @return {PromiEvent}  EventEmitter\n   */\n  allEvents: function (web3Instance) {\n    const constructor = this;\n    const decode = utils.decodeLogs;\n    let currentLogID = null;\n\n    // Someone upstream is firing duplicates :/\n    function dedupe(id) {\n      return id === currentLogID ? false : (currentLogID = id);\n    }\n\n    return function (params) {\n      const emitter = new EventEmitter();\n\n      constructor.detectNetwork().then(() => {\n        const event = web3Instance.events.allEvents(params);\n\n        event.on(\n          \"data\",\n          e =>\n            dedupe(e.id) &&\n            emitter.emit(\"data\", decode.call(constructor, e, true)[0])\n        );\n        event.on(\n          \"changed\",\n          e =>\n            dedupe(e.id) &&\n            emitter.emit(\"changed\", decode.call(constructor, e, true)[0])\n        );\n        event.on(\"error\", e => emitter.emit(\"error\", e));\n      });\n\n      return emitter;\n    };\n  },\n\n  /**\n   * Wraps web3 `getPastEvents`, with additional log decoding\n   * @return {Promise}  Resolves array of event objects\n   */\n  getPastEvents: function (web3Instance) {\n    const constructor = this;\n    const decode = utils.decodeLogs;\n\n    return function (event, options) {\n      return web3Instance\n        .getPastEvents(event, options)\n        .then(events => decode.call(constructor, events, false));\n    };\n  },\n\n  /**\n   * Estimates gas cost of a method invocation\n   * @param  {Function} fn  Method to target\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @return {Promise}\n   */\n  estimate: function (fn, methodABI) {\n    const constructor = this;\n    return function () {\n      return execute\n        .prepareCall(constructor, methodABI, arguments)\n        .then(res => fn(...res.args).estimateGas(res.params));\n    };\n  },\n\n  /**\n   *\n   * @param  {Function} fn  Method to target\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @return {Promise}\n   */\n  request: function (fn, methodABI, address) {\n    const constructor = this;\n    return function () {\n      return execute\n        .prepareCall(constructor, methodABI, arguments)\n        .then(res => {\n          //clone res.params\n          let tx = {};\n          for (let key in res.params) {\n            tx[key] = res.params[key];\n          }\n          //set to\n          tx.to = address;\n          //set data\n          tx.data = fn(...res.args).encodeABI();\n          return tx;\n        });\n    };\n  },\n\n  // This gets attached to `.new` (declared as a static_method in `contract`)\n  // during bootstrapping as `estimateGas`\n  estimateDeployment: function () {\n    const constructor = this;\n\n    const constructorABI = constructor.abi.filter(\n      i => i.type === \"constructor\"\n    )[0];\n\n    return execute\n      .prepareCall(constructor, constructorABI, arguments)\n      .then(res => {\n        const options = {\n          data: constructor.binary,\n          arguments: res.args\n        };\n\n        delete res.params[\"data\"]; // Is this necessary?\n\n        const instance = new constructor.web3.eth.Contract(\n          constructor.abi,\n          res.params\n        );\n        return instance.deploy(options).estimateGas(res.params);\n      });\n  },\n\n  // This gets attached to `.new` (declared as a static_method in `contract`)\n  // during bootstrapping as `request`\n  requestDeployment: function () {\n    const constructor = this;\n\n    const constructorABI = constructor.abi.filter(\n      i => i.type === \"constructor\"\n    )[0];\n\n    return execute\n      .prepareCall(constructor, constructorABI, arguments)\n      .then(res => {\n        //clone res.params\n        let tx = {};\n        for (let key in res.params) {\n          tx[key] = res.params[key];\n        }\n\n        const options = {\n          data: constructor.binary,\n          arguments: res.args\n        };\n\n        const instance = new constructor.web3.eth.Contract(\n          constructor.abi,\n          res.params\n        );\n        tx.data = instance.deploy(options).encodeABI();\n        return tx;\n      });\n  },\n\n  //our own custom sendTransaction function, made to mimic web3's,\n  //while also being able to do things, like, say, store the transaction\n  //hash even in case of failure.  it's not as powerful in some ways,\n  //as it just returns an ordinary Promise rather than web3's PromiEvent,\n  //but it's more suited to our purposes (we're not using that PromiEvent\n  //functionality here anyway)\n  //input works the same as input to web3.sendTransaction\n  //(well, OK, it's lacking some things there too, but again, good enough\n  //for our purposes)\n  sendTransaction: async function (web3, params, promiEvent, context) {\n    //if we don't need the debugger, let's not risk any errors on our part,\n    //and just have web3 do everything\n    if (!promiEvent || !promiEvent.debug) {\n      const deferred = web3.eth.sendTransaction(params);\n      handlers.setup(deferred, context);\n      return deferred;\n    }\n    //otherwise, do things manually!\n    //(and skip the PromiEvent stuff :-/ )\n    return sendTransactionManual(web3, params, promiEvent);\n  }\n};\n\nmodule.exports = execute;\n"]},"metadata":{},"sourceType":"script"}